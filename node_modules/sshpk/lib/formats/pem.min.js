function read(e,t,r){var n=e;"string"!=typeof e&&(assert.buffer(e,"buf"),e=e.toString("ascii"));var i=e.trim().split("\n"),a=i[0].match(/[-]+[ ]*BEGIN ([A-Z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);assert.ok(a,"invalid PEM header");var o=i[i.length-1].match(/[-]+[ ]*END ([A-Z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);assert.ok(o,"invalid PEM footer"),assert.equal(a[2],o[2]);var u,s=a[2].toLowerCase();a[1]&&(assert.equal(a[1],o[1],"PEM header and footer mismatch"),u=a[1].trim());for(var l={};;){if(i=i.slice(1),a=i[0].match(/^([A-Za-z0-9-]+): (.+)$/),!a)break;l[a[1].toLowerCase()]=a[2]}var c,f,p;if(l["proc-type"]){var h=l["proc-type"].split(",");if("4"===h[0]&&"ENCRYPTED"===h[1]){if("string"==typeof t.passphrase&&(t.passphrase=new Buffer(t.passphrase,"utf-8")),!Buffer.isBuffer(t.passphrase))throw new errors.KeyEncryptedError(t.filename,"PEM");h=l["dek-info"].split(","),assert.ok(2===h.length),c=h[0].toLowerCase(),p=new Buffer(h[1],"hex"),f=utils.opensslKeyDeriv(c,p,t.passphrase,1).key}}if(i=i.slice(0,-1).join(""),e=new Buffer(i,"base64"),c&&f&&p){var m,d=crypto.createDecipheriv(c,f,p),v=[];for(d.once("error",function(e){if(-1!==e.toString().indexOf("bad decrypt"))throw new Error("Incorrect passphrase supplied, could not decrypt key");throw e}),d.write(e),d.end();null!==(m=d.read());)v.push(m);e=Buffer.concat(v)}if(u&&"openssh"===u.toLowerCase())return sshpriv.readSSHPrivate(s,e,t);if(u&&"ssh2"===u.toLowerCase())return rfc4253.readType(s,e,t);var g=new asn1.BerReader(e);return g.originalInput=n,g.readSequence(),u?(r&&assert.strictEqual(r,"pkcs1"),pkcs1.readPkcs1(u,s,g)):(r&&assert.strictEqual(r,"pkcs8"),pkcs8.readPkcs8(u,s,g))}function write(e,t,r){assert.object(e);var i,n={ecdsa:"EC",rsa:"RSA",dsa:"DSA"}[e.type],a=new asn1.BerWriter;if(PrivateKey.isPrivateKey(e))r&&"pkcs8"===r?(i="PRIVATE KEY",pkcs8.writePkcs8(a,e)):(r&&assert.strictEqual(r,"pkcs1"),i=n+" PRIVATE KEY",pkcs1.writePkcs1(a,e));else{if(!Key.isKey(e))throw new Error("key is not a Key or PrivateKey");r&&"pkcs1"===r?(i=n+" PUBLIC KEY",pkcs1.writePkcs1(a,e)):(r&&assert.strictEqual(r,"pkcs8"),i="PUBLIC KEY",pkcs8.writePkcs8(a,e))}var o=a.buffer.toString("base64"),s=o.length+o.length/64+18+16+2*i.length+10,u=new Buffer(s),l=0;l+=u.write("-----BEGIN "+i+"-----\n",l);for(var c=0;c<o.length;){var f=c+64;f>o.length&&(f=o.length),l+=u.write(o.slice(c,f),l),u[l++]=10,c=f}return l+=u.write("-----END "+i+"-----\n",l),u.slice(0,l)}module.exports={read:read,write:write};var assert=require("assert-plus"),asn1=require("asn1"),crypto=require("crypto"),algs=require("../algs"),utils=require("../utils"),Key=require("../key"),PrivateKey=require("../private-key"),pkcs1=require("./pkcs1"),pkcs8=require("./pkcs8"),sshpriv=require("./ssh-private"),rfc4253=require("./rfc4253"),errors=require("../errors");