function PrivateKey(e){assert.object(e,"options"),Key.call(this,e),this._pubCache=void 0}module.exports=PrivateKey;var assert=require("assert-plus"),algs=require("./algs"),crypto=require("crypto"),Fingerprint=require("./fingerprint"),Signature=require("./signature"),errs=require("./errors"),util=require("util"),utils=require("./utils"),dhe=require("./dhe"),generateECDSA=dhe.generateECDSA,generateED25519=dhe.generateED25519,edCompat,nacl;try{edCompat=require("./ed-compat")}catch(e){}var Key=require("./key"),InvalidAlgorithmError=errs.InvalidAlgorithmError,KeyParseError=errs.KeyParseError,KeyEncryptedError=errs.KeyEncryptedError,formats={};formats.auto=require("./formats/auto"),formats.pem=require("./formats/pem"),formats.pkcs1=require("./formats/pkcs1"),formats.pkcs8=require("./formats/pkcs8"),formats.rfc4253=require("./formats/rfc4253"),formats["ssh-private"]=require("./formats/ssh-private"),formats.openssh=formats["ssh-private"],formats.ssh=formats["ssh-private"],util.inherits(PrivateKey,Key),PrivateKey.formats=formats,PrivateKey.prototype.toBuffer=function(e,t){return void 0===e&&(e="pkcs1"),assert.string(e,"format"),assert.object(formats[e],"formats[format]"),assert.optionalObject(t,"options"),formats[e].write(this,t)},PrivateKey.prototype.hash=function(e){return this.toPublic().hash(e)},PrivateKey.prototype.toPublic=function(){if(this._pubCache)return this._pubCache;for(var e=algs.info[this.type],t=[],r=0;r<e.parts.length;++r){var n=e.parts[r];t.push(this.part[n])}return this._pubCache=new Key({type:this.type,source:this,parts:t}),this.comment&&(this._pubCache.comment=this.comment),this._pubCache},PrivateKey.prototype.derive=function(e){assert.string(e,"type");var t,r,n;if("ed25519"===this.type&&"curve25519"===e)return void 0===nacl&&(nacl=require("tweetnacl")),t=this.part.r.data,0===t[0]&&(t=t.slice(1)),t=t.slice(0,32),n=nacl.box.keyPair.fromSecretKey(new Uint8Array(t)),r=new Buffer(n.publicKey),t=Buffer.concat([t,r]),new PrivateKey({type:"curve25519",parts:[{name:"R",data:utils.mpNormalize(r)},{name:"r",data:t}]});if("curve25519"===this.type&&"ed25519"===e)return void 0===nacl&&(nacl=require("tweetnacl")),t=this.part.r.data,0===t[0]&&(t=t.slice(1)),t=t.slice(0,32),n=nacl.sign.keyPair.fromSeed(new Uint8Array(t)),r=new Buffer(n.publicKey),t=Buffer.concat([t,r]),new PrivateKey({type:"ed25519",parts:[{name:"R",data:utils.mpNormalize(r)},{name:"r",data:t}]});throw new Error("Key derivation not supported from "+this.type+" to "+e)},PrivateKey.prototype.createVerify=function(e){return this.toPublic().createVerify(e)},PrivateKey.prototype.createSign=function(e){if(void 0===e&&(e=this.defaultHashAlgorithm()),assert.string(e,"hash algorithm"),"ed25519"===this.type&&void 0!==edCompat)return new edCompat.Signer(this,e);if("curve25519"===this.type)throw new Error("Curve25519 keys are not suitable for signing or verification");var t,r,n;try{r=e.toUpperCase(),t=crypto.createSign(r)}catch(i){n=i}(void 0===t||n instanceof Error&&n.message.match(/Unknown message digest/))&&(r="RSA-",r+=e.toUpperCase(),t=crypto.createSign(r)),assert.ok(t,"failed to create verifier");var a=t.sign.bind(t),o=this.toBuffer("pkcs1"),s=this.type,u=this.curve;return t.sign=function(){var t=a(o);return"string"==typeof t&&(t=new Buffer(t,"binary")),t=Signature.parse(t,s,"asn1"),t.hashAlgorithm=e,t.curve=u,t},t},PrivateKey.parse=function(e,t,r){"string"!=typeof e&&assert.buffer(e,"data"),void 0===t&&(t="auto"),assert.string(t,"format"),"string"==typeof r&&(r={filename:r}),assert.optionalObject(r,"options"),void 0===r&&(r={}),assert.optionalString(r.filename,"options.filename"),void 0===r.filename&&(r.filename="(unnamed)"),assert.object(formats[t],"formats[format]");try{var n=formats[t].read(e,r);return assert.ok(n instanceof PrivateKey,"key is not a private key"),n.comment||(n.comment=r.filename),n}catch(i){if("KeyEncryptedError"===i.name)throw i;throw new KeyParseError(r.filename,t,i)}},PrivateKey.isPrivateKey=function(e,t){return utils.isCompatible(e,PrivateKey,t)},PrivateKey.generate=function(e,t){switch(void 0===t&&(t={}),assert.object(t,"options"),e){case"ecdsa":return void 0===t.curve&&(t.curve="nistp256"),assert.string(t.curve,"options.curve"),generateECDSA(t.curve);case"ed25519":return generateED25519();default:throw new Error('Key generation not supported with key type "'+e+'"')}},PrivateKey.prototype._sshpkApiVersion=[1,4],PrivateKey._oldVersionDetect=function(e){return assert.func(e.toPublic),assert.func(e.createSign),e.derive?[1,3]:e.defaultHashAlgorithm?[1,2]:e.formats.auto?[1,1]:[1,0]};